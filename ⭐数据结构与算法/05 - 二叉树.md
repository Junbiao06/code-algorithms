## 2025年10月30日
![[Pasted image 20251029135224.png|100]]

## 递归
### 递归序
![[Pasted image 20251029135424.png|300]]

### 先序（头、左、右）
> 递归序中第一次出现打印。

1245367
#### 步骤
1. 弹出curr。
2. 处理curr。
3. 先右后左进栈。
4. cycle

#### 递归写法
```js
    const preOrderRecur = function (head) {
      if (head === null) return null;
      document.write(head.val);
      preOrderRecur(head.left);
      preOrderRecur(head.right);
    }
```
#### 非递归写法
```js
    const preOrderUnRecur = function (head) {
      if (head !== null) {
        const stack = [];
        stack.push(head);
        while (stack.length !== 0) {
          head = stack.pop();
          document.write(head.val)
          if (head.right) {
            stack.push(head.right)
          }
          if (head.left) {
            stack.push(head.left)
          }
        }
      }
    }
```


### 中序（左、头、右）
> 递归序中第二次出现打印。

4251637
#### 步骤
1. 每棵子树，整个树左边界进栈。
2. 弹出。
3. 对弹出节点的右树周而复始

#### 递归
```js
    const inOrderRecur = function (head) {
      if (head === null) return null;
      inOrderRecur(head.left);
      document.write(head.val);
      inOrderRecur(head.right);
    }
```

#### 非递归
```js
    const inOrderUnRecur = function (head) {
      if (head !== null) {
        const stack = [];
        while (stack.length !== 0 || head) {
          if (head) {
            stack.push(head);
            head = head.left;
          } else {
            head = stack.pop();
            document.write(head.val);
            head = head.right;
          }
        }
      }
    }
```


### 后序（左、右、头）
> 递归序中第三次出现打印。

4526731

#### 步骤
1. 弹出curr，准备两个栈。
2. 将curr放入额外栈。
3. 先左再右，进栈。
4. cycle
#### 递归
```js
    const posOrderRecur = function (head) {
      if (head === null) return null;
      posOrderRecur(head.left);
      document.write(head.val);
      posOrderRecur(head.right);
    }
```

#### 非递归
```js
    const posOrderUnRecur = function (head) {
      if (head !== null) {
        const s1 = [];
        const s2 = [];
        s1.push(head);
        while (s1.length !== 0) {
          head = s1.pop();
          s2.push(head)
          if (head.left) stack.push(head.left);
          if (head.right) stack.push(head.right);
        }
        while (s2.length !== 0) {
          document.write(s2.pop().val)
        }
      }
```

### 二叉树宽度优先遍历
- 逐层按照头、左、右遍历
- 使用队列
```js
    const bfs = function (head) {
      if (head === null) return null;
      const queue = [];
      queue.push(head);
      while (queue.length !== 0) {
        const cur = queue.shift();
        document.write(cur.val);
        if (cur.left) queue.push(cur.left);
        if (cur.right) queue.push(cur.right);
      }
    };
```

### 求二叉树最大宽度
```js
    const widthOfBinaryTree = function (head) {
      if (head === null) return null;
      const queue = [];
      queue.push(head);

      const map = new Map();
      map.set(head, 1);
      let curLevel = 1;
      let curLevelNodes = 0;
      let max = 0
      while (queue.length !== 0) {
        const cur = queue.shift();
        let curNodeLevel = map.get(cur);
        if (curNodeLevel === curLevel) {
          curLevelNodes++;
        } else {
          max = Math.max(max, curLevelNodes);
          curLevel++;
          curLevelNodes = 1
        }
        if (cur.left) {
          map.set(cur.left, curNodeLevel + 1);
          queue.push(cur.left);
        }
        if (cur.right) {
          map.set(cur.right, curNodeLevel + 1);
          queue.push(cur.right);
        }
      }
      max = Math.max(max, curLevelNodes);
      return max;
    }
```