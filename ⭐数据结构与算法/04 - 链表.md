## 2025年10月25日
## 哈希表和有序表的简单介绍
### 哈希表
> 键值对，有key有value是map，有key没有value是set。时间复杂度O(1)。基础类型按值传递，非基础类型按引用传递。Object也是哈希表。

#### 增删改查
- `new Map()`
- `set(key, value)`
- `get(key)`
- `has(key)`，返回boolean
- `for [key, value] of`
- `forEach()`
- `...map.keys()`
- `...map.values()`
- `...map.entries()`
- `delete(key)`
- `clear()`
- `size()`

### 有序表
> 有序的哈希表。O(logN)。红黑树、AVL树、size-balance-tree和跳表都是有序表结构。

## 链表

### 链表解题方法论
- 额外数据结构记录（哈希表）。
- 快慢指针。
- 笔试：只关注时间复杂度，做出来就完了。
- 面试：保证时间复杂度的情况下，做到空间最省。

### 引入题目
#### 反转链表
#### 打印两个有序链表的公共元素
- 归并思想
## 【题目1】回文链表
##### 1. 利用栈结构，实现通过n个空间进行判断
##### 2. 利用栈结构，实现通过n/2个空间进行判断
```js
    const isPalindrome2 = function (head) {
      const stack = new Array();
      if (head === null || head.next === null) return true;
      let slow = head.next;
      let fast = head;
      while (fast.next !== null && fast.next.next !== null) {
        fast = fast.next.next
        slow = slow.next
      }
      while (slow !== null) {
        stack.push(slow);
        slow = slow.next;
      }
      while (stack.length > 0) {
        if (head.val !== stack.pop().val) return false;
        head = head.next;
      }
      return true
    }
```

##### 3. 实现空间复杂度为1的算法
```js
    const isPalindrome3 = function (head) {
      if (head === null || head.next === null) return true
      let n1 = head;
      let n2 = head;
      while (n2.next !== null && n2.next.next !== null) {
        n1 = n1.next;
        n2 = n2.next.next;
      }
      n2 = n1.next;
      n1.next = null;
      let n3 = null;
      while (n2 !== null) {
        n3 = n2.next;
        n2.next = n1;
        n1 = n2;
        n2 = n3;
      }
      n3 = n1;
      n2 = head;
      let res = true;
      while (n1 && n2) {
        if (n1.val != n2.val) {
          res = false;
          break;
        }
        n1 = n1.next;
        n2 = n2.next;
      }
      n1 = n3.next;
      n3.next = null;
      // 以下是还原链表
      while (n1 != null) {
        n2 = n1.next;
        n1.next = n3;
        n3 = n1;
        n1 = n2;
      }
      return res;
    }
```

## 【题目2】链表划分（荷兰国旗问题）
```js
    const partition = function (head, x) {
      let sh = st = eh = et = lh = lt = null;
      let dummy = new ListNode(-1);
      let tail = dummy;
      while (head) {
        const next = head.next;
        head.next = null
        if (head.val < x) {
          if (sh === null) sh = st = head
          else {
            st.next = head
            st = head
          }
        }
        else if (head.val === x) {
          if (eh === null) eh = et = head
          else {
            et.next = head
            et = head
          }
        }
        else {
          if (lh === null) lh = lt = head
          else {
            lt.next = head
            lt = head
          }
        }
        head = next;
      }
      while (sh) {
        tail.next = sh;
        sh = sh.next;
        tail = tail.next;
      }
      while (eh) {
        tail.next = eh;
        eh = eh.next;
        tail = tail.next;
      }
      while (lh) {
        tail.next = lh;
        lh = lh.next;
        tail = tail.next
      }
      return dummy.next
    };
```

## 【题目3】复制含有随机指针节点的链表
##### 1. 利用哈希表
```js

```

##### 2. 克隆节点
```js

```
![[Pasted image 20251030141730.png|300]]

## 【题目4】两个单链表相交节点
- 给两个可能有环可能无环的单链表，头节点head1，head2。若两个链表相交，则返回第一个相交的节点，否则返回null。

### 一、找一个环形链表的入环节点loop
1. set
```js
    const getLoopNode = function (head) {
      let set = new Set();
      let p = head;
      while (p) {
        if (set.has(p)) return p;
        set.add(p);
        p = p.next;
      }
      return null;
    }
```
2. 快慢指针（见过就会，没见过就瞎）
- 快慢指针相遇时，快指针返回头指针，两个指针一步一步走直至相遇。
```js
    const getLoopNode = function (head) {
      if (!head || !head.next) return null;
      let slow = head;
      let fast = head;
      while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow === fast) {
          fast = head;
          while (fast !== slow) {
            fast = fast.next;
            slow = slow.next;
          }
          return fast;
        }
      }
      return null;
    }
```

### 二、分类讨论
#### 一、都无环
1. 判断尾地址是否相等，然后从剩余length相同的地方开始遍历
```js
    const noLoop = function (head1, head2) {
      if (!head1 || !head2) return null;
      let cur1 = head1;
      let cur2 = head2;
      let n = 0
      while (cur1.next) {
        n++
        cur1 = cur1.next;
      }
      while (cur2.next) {
        n--
        cur2 = cur2.next;
      }
      if (cur1 !== cur2) return null;
      cur1 = n > 0 ? cur1 : cur2;
      cur2 = cur1 === cur2 ? cur1 : cur2;
      n = Math.abs(n);
      while (n != 0) {
        n--;
        cur1 = cur1.next;
      }
      while (cur1 !== cur2) {
        cur1 = cur1.next;
        cur2 = cur2.next;
      }
      return cur1;
    }
```
2. 没讲的方法（遍历两遍）
```js
    const noLoop = function (head1, head2) {
      let p1 = head1;
      let p2 = head2;
      while (p1 !== p2) {
        p1 = p1 ? p1.next : head2;
        p2 = p2 ? p2.next : head1;
      }
      return p1;
    }
```

#### 二、一个有环一个无环
不可能
#### 三、都有环
三种情况，值得注意的是第三种情况，返回哪个loop都应该是对的。
![[Pasted image 20251028142355.png|200]]
```js
    const bothLoop = function (head1, head2, loop1, loop2) {
      if (loop1 === loop2) {
        let cur1 = head1;
        let cur2 = head2;
        let n = 0;
        while (cur1 !== loop1) {
          n++;
          cur1 = cur1.next;
        }
        while (cur2 !== loop2) {
          n--;
          cur2 = cur2.next;
        }
        cur1 = n > 0 ? head1 : head2;
        cur2 = cur1 === head2 ? head1 : head2;
        n = Math.abs(n);
        while (n !== 0) {
          n--;
          cur1 = cur1.next;
        }
        while (cur1 !== cur2) {
          cur1 = cur1.next;
          cur2 = cur2.next;
        }
        return cur1;
      }
      else {
        cur1 = loop1.next;
        while (cur1 !== loop1) {
          if (cur1 === loop2) return loop2;
          cur1 = cur1.next;
        }
        return null;
      }
    }
```
